<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convolution & Pooling Animator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* A light fallback grey */
            background-image: radial-gradient(circle at center, #d1d5db 0.5px, transparent 0.5px);
            background-size: 20px 20px;
        }
        .main-container {
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .canvas-container {
            /* Responsive canvas container */
            width: 100%;
            max-width: 256px; /* Keep max size for large screens */
            aspect-ratio: 1 / 1; /* Maintain square shape */
            margin: auto; /* Center in grid cell */
        }
        canvas {
            width: 100%;
            height: 100%;
            background-color: #e5e7eb;
            border-radius: 0.5rem;
            image-rendering: pixelated; /* Keeps pixels sharp */
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        /* Button hover effects */
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:not(:disabled):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .save-btn {
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .save-btn.visible {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="main-container w-full max-w-6xl p-4 sm:p-6 rounded-2xl shadow-2xl">
        <h1 class="text-2xl sm:text-3xl font-bold text-center mb-2">Interactive CNN Visualizer</h1>
        <p class="text-center text-gray-600 mb-6">Drag & drop, paste, or click to upload an image.</p>
        
        <!-- Controls -->
        <div id="controls" class="flex flex-col md:flex-row items-center justify-center gap-6 mb-6">
            <div id="drop-zone" class="w-full md:w-96 h-48 border-2 border-dashed border-gray-300 rounded-lg flex items-center justify-center text-center text-gray-500 transition-all duration-300 bg-gray-50/50 hover:bg-blue-50 hover:border-blue-400 cursor-pointer p-4">
                <input type="file" id="file-upload" class="hidden" accept="image/*">
                <p id="drop-text">Drag & drop, paste, or click to upload an image</p>
                <img id="preview" class="hidden h-full w-auto object-contain rounded-md p-1" />
            </div>
            <div class="flex flex-col gap-4 w-full md:w-auto">
                <!-- Options -->
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="kernel-select" class="block text-sm font-medium text-gray-700">Kernel</label>
                        <select id="kernel-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="sharpen" selected>Sharpen</option>
                            <option value="sobel_x">Sobel X (Vertical Edges)</option>
                            <option value="sobel_y">Sobel Y (Horizontal Edges)</option>
                            <option value="laplacian">Edge Detect</option>
                        </select>
                    </div>
                    <div>
                        <label for="pooling-select" class="block text-sm font-medium text-gray-700">Pooling</label>
                        <select id="pooling-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
                            <option value="max" selected>Max Pooling</option>
                            <option value="min">Min Pooling</option>
                        </select>
                    </div>
                </div>
                <!-- Buttons -->
                <div id="button-group" class="flex flex-col gap-2">
                    <button id="start-btn" disabled class="btn w-full bg-blue-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">Start Conv Animation</button>
                    <button id="ff-btn" class="btn w-full bg-purple-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-purple-700 disabled:bg-gray-400 hidden">Fast Forward Conv</button>
                    <button id="skip-btn" class="btn w-full bg-gray-500 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-gray-600 disabled:bg-gray-400 hidden">Skip Convolution</button>
                    <button id="pooling-btn" class="btn w-full bg-green-600 text-white font-bold py-2 px-6 rounded-lg shadow-md hover:bg-green-700 disabled:bg-gray-400 hidden">Start Pooling Animation</button>
                </div>
            </div>
        </div>
        
        <!-- Animation Display -->
        <div id="animation-container" class="hidden">
            <div id="loader" class="text-center py-12">
                 <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
                 <p class="mt-4 text-gray-600">Processing image on server...</p>
            </div>
            <div id="visuals" class="hidden grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 items-start justify-items-center">
                <div class="text-center w-full max-w-xs">
                    <h2 class="text-lg font-semibold mb-2">1. Input Image</h2>
                    <div class="canvas-container relative">
                        <canvas id="input-canvas"></canvas>
                        <a id="save-input" class="save-btn absolute top-2 right-2 bg-white/50 backdrop-blur-sm p-1.5 rounded-full text-gray-700 hover:bg-white cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </a>
                    </div>
                </div>
                <div class="text-center w-full max-w-xs">
                    <h2 id="sharpened-title" class="text-lg font-semibold mb-2">2. Convolution Output</h2>
                    <div class="canvas-container relative">
                        <canvas id="sharpened-canvas"></canvas>
                        <a id="save-sharpened" class="save-btn absolute top-2 right-2 bg-white/50 backdrop-blur-sm p-1.5 rounded-full text-gray-700 hover:bg-white cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </a>
                    </div>
                </div>
                <div class="text-center w-full max-w-xs">
                    <h2 class="text-lg font-semibold mb-2">Current Patch</h2>
                    <div class="canvas-container"><canvas id="patch-canvas"></canvas></div>
                </div>
                <div class="text-center w-full max-w-xs">
                    <h2 id="pooled-title" class="text-lg font-semibold mb-2">3. Pooling Output</h2>
                    <div class="canvas-container relative">
                        <canvas id="pooled-canvas"></canvas>
                        <a id="save-pooled" class="save-btn absolute top-2 right-2 bg-white/50 backdrop-blur-sm p-1.5 rounded-full text-gray-700 hover:bg-white cursor-pointer">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const dropZone = document.getElementById('drop-zone');
        const dropText = document.getElementById('drop-text');
        const preview = document.getElementById('preview');
        const startBtn = document.getElementById('start-btn');
        const ffBtn = document.getElementById('ff-btn');
        const skipBtn = document.getElementById('skip-btn');
        const poolingBtn = document.getElementById('pooling-btn');
        const animationContainer = document.getElementById('animation-container');
        const loader = document.getElementById('loader');
        const visuals = document.getElementById('visuals');
        const kernelSelect = document.getElementById('kernel-select');
        const poolingSelect = document.getElementById('pooling-select');
        const sharpenedTitle = document.getElementById('sharpened-title');
        const pooledTitle = document.getElementById('pooled-title');
        const fileUpload = document.getElementById('file-upload');

        // Canvases & Contexts
        const canvases = {
            input: document.getElementById('input-canvas'),
            sharpened: document.getElementById('sharpened-canvas'),
            patch: document.getElementById('patch-canvas'),
            pooled: document.getElementById('pooled-canvas')
        };
        const contexts = {
            input: canvases.input.getContext('2d'),
            sharpened: canvases.sharpened.getContext('2d'),
            patch: canvases.patch.getContext('2d'),
            pooled: canvases.pooled.getContext('2d')
        };
        
        // Save Buttons
        const saveLinks = {
            input: document.getElementById('save-input'),
            sharpened: document.getElementById('save-sharpened'),
            pooled: document.getElementById('save-pooled')
        };

        // State
        let uploadedImageFile = null;
        let animationFrameId = null;
        let imageSources = {};
        let imageObjects = {};
        let isFastForwarding = false;
        let isAnimationRunning = false;

        // --- Image Input Logic (Drag & Drop, Paste, Click) ---
        function handleFileSelect(file) {
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    uploadedImageFile = event.target.result;
                    preview.src = uploadedImageFile;
                    preview.classList.remove('hidden');
                    dropText.classList.add('hidden');
                    animationContainer.classList.add('hidden');
                    Object.values(saveLinks).forEach(link => link.classList.remove('visible'));
                    updateButtonState('initial');
                };
                reader.readAsDataURL(file);
            }
        }
        
        // Drag and Drop
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-400', 'bg-blue-50'); });
        dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-blue-400', 'bg-blue-50'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('border-blue-400', 'bg-blue-50');
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleFileSelect(e.dataTransfer.files[0]);
            }
        });

        // Click to Upload
        dropZone.addEventListener('click', () => fileUpload.click());
        fileUpload.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                handleFileSelect(e.target.files[0]);
            }
        });

        // Paste from Clipboard
        window.addEventListener('paste', e => {
            const items = e.clipboardData.items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const file = items[i].getAsFile();
                    if(file) handleFileSelect(file);
                    e.preventDefault();
                    return; // Stop after handling the first image
                }
            }
        });

        // --- API Call ---
        async function processImageOnServer() {
            if (!uploadedImageFile) return false;

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationContainer.classList.remove('hidden');
            visuals.classList.add('hidden');
            loader.classList.remove('hidden');
            updateButtonState('processing');

            const selectedKernelText = kernelSelect.options[kernelSelect.selectedIndex].text;
            const selectedPoolingText = poolingSelect.options[poolingSelect.selectedIndex].text;
            sharpenedTitle.textContent = `2. ${selectedKernelText}`;
            pooledTitle.textContent = `3. ${selectedPoolingText}`;

            try {
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        image: uploadedImageFile,
                        kernel_type: kernelSelect.value,
                        pooling_type: poolingSelect.value
                    }),
                });
                if (!response.ok) throw new Error(`Server error: ${response.statusText}`);
                
                imageSources = await response.json();
                await loadImages();
                
                loader.classList.add('hidden');
                visuals.classList.remove('hidden');
                return true;

            } catch (error) {
                console.error("Processing failed:", error);
                alert("An error occurred. Please check the console.");
                loader.classList.add('hidden');
                updateButtonState('initial');
                return false;
            }
        }
        
        function loadImages() {
            return new Promise((resolve) => {
                const promises = Object.keys(imageSources).map(key => {
                    return new Promise(resolveImg => {
                        const img = new Image();
                        img.onload = () => { imageObjects[key] = img; resolveImg(); };
                        img.src = imageSources[key];
                    });
                });
                Promise.all(promises).then(resolve);
            });
        }
        
        // --- Button Listeners & State Management ---
        startBtn.addEventListener('click', async () => {
            isFastForwarding = false;
            if (await processImageOnServer()) runConvolutionAnimation();
        });
        
        ffBtn.addEventListener('click', async () => {
            if (isAnimationRunning) {
                isFastForwarding = true;
                ffBtn.disabled = true; // Disable after clicking once
                return;
            }
            isFastForwarding = true;
            if (ffBtn.textContent.includes('Conv')) {
                if (await processImageOnServer()) runConvolutionAnimation();
            } else {
                runPoolingAnimation();
            }
        });

        skipBtn.addEventListener('click', async () => {
            if (skipBtn.textContent.includes('Convolution')) {
                if (await processImageOnServer()) showFinalConvolution();
            } else {
                showFinalPooling();
            }
        });

        poolingBtn.addEventListener('click', () => {
            isFastForwarding = false;
            runPoolingAnimation();
        });

        function updateButtonState(state) {
            const allButtons = [startBtn, ffBtn, skipBtn, poolingBtn];
            allButtons.forEach(btn => {
                btn.disabled = true;
                btn.classList.add('hidden');
            });

            switch(state) {
                case 'initial':
                    startBtn.disabled = false;
                    startBtn.classList.remove('hidden');
                    ffBtn.textContent = 'Fast Forward Conv';
                    ffBtn.disabled = false;
                    ffBtn.classList.remove('hidden');
                    skipBtn.textContent = 'Skip Convolution';
                    skipBtn.disabled = false;
                    skipBtn.classList.remove('hidden');
                    break;
                case 'processing':
                    // All buttons are disabled and hidden by default
                    break;
                case 'convRunning':
                    startBtn.classList.remove('hidden'); 
                    ffBtn.textContent = 'Fast Forward Conv';
                    ffBtn.disabled = false;
                    ffBtn.classList.remove('hidden');
                    skipBtn.textContent = 'Skip Convolution';
                    skipBtn.disabled = false;
                    skipBtn.classList.remove('hidden');
                    break;
                case 'convFinished':
                    startBtn.classList.remove('hidden');
                    poolingBtn.disabled = false;
                    poolingBtn.classList.remove('hidden');
                    ffBtn.textContent = 'Fast Forward Pool';
                    ffBtn.disabled = false;
                    ffBtn.classList.remove('hidden');
                    skipBtn.textContent = 'Skip Pooling';
                    skipBtn.disabled = false;
                    skipBtn.classList.remove('hidden');
                    break;
                case 'poolingRunning':
                    startBtn.classList.remove('hidden');
                    poolingBtn.classList.remove('hidden');
                    ffBtn.textContent = 'Fast Forward Pool';
                    ffBtn.disabled = false;
                    ffBtn.classList.remove('hidden');
                    skipBtn.textContent = 'Skip Pooling';
                    skipBtn.disabled = false;
                    skipBtn.classList.remove('hidden');
                    break;
                case 'finished':
                    startBtn.disabled = false;
                    startBtn.classList.remove('hidden');
                    break;
            }
        }
        
        // --- Animation & Save Functions ---
        function setupSaveLink(link, canvas, filename) {
            link.href = canvas.toDataURL('image/png');
            link.download = filename;
            link.classList.add('visible');
        }

        function setupCanvases() {
            canvases.input.width = imageObjects.input_image.width;
            canvases.input.height = imageObjects.input_image.height;
            canvases.sharpened.width = imageObjects.sharpened_image.width;
            canvases.sharpened.height = imageObjects.sharpened_image.height;
            canvases.pooled.width = imageObjects.pooled_image.width;
            canvases.pooled.height = imageObjects.pooled_image.height;
            
            Object.values(contexts).forEach(ctx => {
                ctx.fillStyle = '#e5e7eb';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            });
            Object.values(saveLinks).forEach(link => link.classList.remove('visible'));
        }
        
        function runConvolutionAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            setupCanvases();
            isAnimationRunning = true;
            updateButtonState('convRunning');
            
            canvases.patch.width = 3;
            canvases.patch.height = 3;
            
            const { input_image, sharpened_image } = imageObjects;
            contexts.input.drawImage(input_image, 0, 0);
            setupSaveLink(saveLinks.input, canvases.input, 'input_image.png');

            let frame = 0;
            const outputWidth = sharpened_image.width;
            const outputHeight = sharpened_image.height;
            const totalFrames = outputWidth * outputHeight;

            function animate() {
                const framesPerTick = isFastForwarding ? Math.max(1, Math.floor(outputWidth / 2)) : 1;
                for (let step = 0; step < framesPerTick && frame < totalFrames; step++) {
                    const i = Math.floor(frame / outputWidth);
                    const j = frame % outputWidth;
                    contexts.sharpened.drawImage(sharpened_image, j, i, 1, 1, j, i, 1, 1);
                    if (step === framesPerTick - 1) {
                        contexts.input.drawImage(input_image, 0, 0);
                        contexts.input.strokeStyle = 'red';
                        contexts.input.lineWidth = 1;
                        contexts.input.strokeRect(j + 0.5, i + 0.5, 3, 3);
                        contexts.patch.drawImage(input_image, j, i, 3, 3, 0, 0, 3, 3);
                    }
                    frame++;
                }
                if (frame >= totalFrames) {
                    showFinalConvolution();
                    return;
                }
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }
        
        function showFinalConvolution() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            isAnimationRunning = false;
            isFastForwarding = false;
            setupCanvases();
            contexts.input.drawImage(imageObjects.input_image, 0, 0);
            contexts.sharpened.drawImage(imageObjects.sharpened_image, 0, 0);
            setupSaveLink(saveLinks.input, canvases.input, 'input_image.png');
            setupSaveLink(saveLinks.sharpened, canvases.sharpened, 'convolution_output.png');
            updateButtonState('convFinished');
        }
        
        function runPoolingAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            isAnimationRunning = true;
            updateButtonState('poolingRunning');

            const { sharpened_image, pooled_image } = imageObjects;
            contexts.sharpened.drawImage(sharpened_image, 0, 0);
            canvases.patch.width = 2;
            canvases.patch.height = 2;

            let frame = 0;
            const outputWidth = pooled_image.width;
            const outputHeight = pooled_image.height;
            const totalFrames = outputWidth * outputHeight;

            function animate() {
                const framesPerTick = isFastForwarding ? Math.max(1, Math.floor(outputWidth / 2)) : 1;
                for (let step = 0; step < framesPerTick && frame < totalFrames; step++) {
                    const i = Math.floor(frame / outputWidth);
                    const j = frame % outputWidth;
                    contexts.pooled.drawImage(pooled_image, j, i, 1, 1, j, i, 1, 1);
                    if (step === framesPerTick - 1) {
                        contexts.sharpened.drawImage(sharpened_image, 0, 0);
                        contexts.sharpened.strokeStyle = 'lime';
                        contexts.sharpened.lineWidth = 1;
                        contexts.sharpened.strokeRect(j * 2 + 0.5, i * 2 + 0.5, 2, 2);
                        contexts.patch.drawImage(sharpened_image, j * 2, i * 2, 2, 2, 0, 0, 2, 2);
                    }
                    frame++;
                }
                if (frame >= totalFrames) {
                    showFinalPooling();
                    return;
                }
                animationFrameId = requestAnimationFrame(animate);
            }
            animate();
        }

        function showFinalPooling() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            isAnimationRunning = false;
            isFastForwarding = false;
            contexts.pooled.drawImage(imageObjects.pooled_image, 0, 0);
            contexts.sharpened.drawImage(imageObjects.sharpened_image, 0, 0);
            setupSaveLink(saveLinks.pooled, canvases.pooled, 'pooling_output.png');
            updateButtonState('finished');
        }

    </script>
</body>
</html>

